/*
API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tmsclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// AutoTestsApiService AutoTestsApi service
type AutoTestsApiService service

type ApiApiV2AutoTestsFlakyBulkPostRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	skip *int32
	take *int32
	orderBy *string
	searchField *string
	searchValue *string
	flakyBulkModel *FlakyBulkModel
}

// Amount of items to be skipped (offset)
func (r ApiApiV2AutoTestsFlakyBulkPostRequest) Skip(skip int32) ApiApiV2AutoTestsFlakyBulkPostRequest {
	r.skip = &skip
	return r
}

// Amount of items to be taken (limit)
func (r ApiApiV2AutoTestsFlakyBulkPostRequest) Take(take int32) ApiApiV2AutoTestsFlakyBulkPostRequest {
	r.take = &take
	return r
}

// SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
func (r ApiApiV2AutoTestsFlakyBulkPostRequest) OrderBy(orderBy string) ApiApiV2AutoTestsFlakyBulkPostRequest {
	r.orderBy = &orderBy
	return r
}

// Property name for searching
func (r ApiApiV2AutoTestsFlakyBulkPostRequest) SearchField(searchField string) ApiApiV2AutoTestsFlakyBulkPostRequest {
	r.searchField = &searchField
	return r
}

// Value for searching
func (r ApiApiV2AutoTestsFlakyBulkPostRequest) SearchValue(searchValue string) ApiApiV2AutoTestsFlakyBulkPostRequest {
	r.searchValue = &searchValue
	return r
}

func (r ApiApiV2AutoTestsFlakyBulkPostRequest) FlakyBulkModel(flakyBulkModel FlakyBulkModel) ApiApiV2AutoTestsFlakyBulkPostRequest {
	r.flakyBulkModel = &flakyBulkModel
	return r
}

func (r ApiApiV2AutoTestsFlakyBulkPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV2AutoTestsFlakyBulkPostExecute(r)
}

/*
ApiV2AutoTestsFlakyBulkPost Set \"Flaky\" status for multiple autotests

User permissions for project:
- Read only
- Execute
- Write
- Full control

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2AutoTestsFlakyBulkPostRequest
*/
func (a *AutoTestsApiService) ApiV2AutoTestsFlakyBulkPost(ctx context.Context) ApiApiV2AutoTestsFlakyBulkPostRequest {
	return ApiApiV2AutoTestsFlakyBulkPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AutoTestsApiService) ApiV2AutoTestsFlakyBulkPostExecute(r ApiApiV2AutoTestsFlakyBulkPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.ApiV2AutoTestsFlakyBulkPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/flaky/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Skip", r.skip, "")
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Take", r.take, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OrderBy", r.orderBy, "")
	}
	if r.searchField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchField", r.searchField, "")
	}
	if r.searchValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchValue", r.searchValue, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.flakyBulkModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV2AutoTestsIdPatchRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
	operation *[]Operation
}

func (r ApiApiV2AutoTestsIdPatchRequest) Operation(operation []Operation) ApiApiV2AutoTestsIdPatchRequest {
	r.operation = &operation
	return r
}

func (r ApiApiV2AutoTestsIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV2AutoTestsIdPatchExecute(r)
}

/*
ApiV2AutoTestsIdPatch Patch auto test

See <a href="https://www.rfc-editor.org/rfc/rfc6902" target="_blank">RFC 6902: JavaScript Object Notation (JSON) Patch</a> for details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Global Id of auto test
 @return ApiApiV2AutoTestsIdPatchRequest
*/
func (a *AutoTestsApiService) ApiV2AutoTestsIdPatch(ctx context.Context, id string) ApiApiV2AutoTestsIdPatchRequest {
	return ApiApiV2AutoTestsIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AutoTestsApiService) ApiV2AutoTestsIdPatchExecute(r ApiApiV2AutoTestsIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.ApiV2AutoTestsIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operation
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV2AutoTestsIdTestResultsSearchPostRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
	skip *int32
	take *int32
	orderBy *string
	searchField *string
	searchValue *string
	autotestHistoricalResultSelectModel *AutotestHistoricalResultSelectModel
}

// Amount of items to be skipped (offset)
func (r ApiApiV2AutoTestsIdTestResultsSearchPostRequest) Skip(skip int32) ApiApiV2AutoTestsIdTestResultsSearchPostRequest {
	r.skip = &skip
	return r
}

// Amount of items to be taken (limit)
func (r ApiApiV2AutoTestsIdTestResultsSearchPostRequest) Take(take int32) ApiApiV2AutoTestsIdTestResultsSearchPostRequest {
	r.take = &take
	return r
}

// SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
func (r ApiApiV2AutoTestsIdTestResultsSearchPostRequest) OrderBy(orderBy string) ApiApiV2AutoTestsIdTestResultsSearchPostRequest {
	r.orderBy = &orderBy
	return r
}

// Property name for searching
func (r ApiApiV2AutoTestsIdTestResultsSearchPostRequest) SearchField(searchField string) ApiApiV2AutoTestsIdTestResultsSearchPostRequest {
	r.searchField = &searchField
	return r
}

// Value for searching
func (r ApiApiV2AutoTestsIdTestResultsSearchPostRequest) SearchValue(searchValue string) ApiApiV2AutoTestsIdTestResultsSearchPostRequest {
	r.searchValue = &searchValue
	return r
}

func (r ApiApiV2AutoTestsIdTestResultsSearchPostRequest) AutotestHistoricalResultSelectModel(autotestHistoricalResultSelectModel AutotestHistoricalResultSelectModel) ApiApiV2AutoTestsIdTestResultsSearchPostRequest {
	r.autotestHistoricalResultSelectModel = &autotestHistoricalResultSelectModel
	return r
}

func (r ApiApiV2AutoTestsIdTestResultsSearchPostRequest) Execute() ([]AutotestResultHistoricalGetModel, *http.Response, error) {
	return r.ApiService.ApiV2AutoTestsIdTestResultsSearchPostExecute(r)
}

/*
ApiV2AutoTestsIdTestResultsSearchPost Get test results history for autotest

<br>Use case
<br>User sets autotest internal (guid format) or global (integer format) identifier
<br>User sets getTestResultHistoryReportQuery (listed in the example)
<br>User runs method execution
<br>System search for test results using filters set by user in getTestResultHistoryReportQuery and id
<br>System returns the enumeration of test results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Autotest identifier
 @return ApiApiV2AutoTestsIdTestResultsSearchPostRequest
*/
func (a *AutoTestsApiService) ApiV2AutoTestsIdTestResultsSearchPost(ctx context.Context, id string) ApiApiV2AutoTestsIdTestResultsSearchPostRequest {
	return ApiApiV2AutoTestsIdTestResultsSearchPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []AutotestResultHistoricalGetModel
func (a *AutoTestsApiService) ApiV2AutoTestsIdTestResultsSearchPostExecute(r ApiApiV2AutoTestsIdTestResultsSearchPostRequest) ([]AutotestResultHistoricalGetModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AutotestResultHistoricalGetModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.ApiV2AutoTestsIdTestResultsSearchPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}/testResults/search"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Skip", r.skip, "")
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Take", r.take, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OrderBy", r.orderBy, "")
	}
	if r.searchField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchField", r.searchField, "")
	}
	if r.searchValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchValue", r.searchValue, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.autotestHistoricalResultSelectModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AutoTestsIdWorkItemsChangedIdGetRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
}

func (r ApiApiV2AutoTestsIdWorkItemsChangedIdGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.ApiV2AutoTestsIdWorkItemsChangedIdGetExecute(r)
}

/*
ApiV2AutoTestsIdWorkItemsChangedIdGet Get identifiers of changed linked work items

User permissions for project:
- Read only
- Execute
- Write
- Full control

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiApiV2AutoTestsIdWorkItemsChangedIdGetRequest
*/
func (a *AutoTestsApiService) ApiV2AutoTestsIdWorkItemsChangedIdGet(ctx context.Context, id string) ApiApiV2AutoTestsIdWorkItemsChangedIdGetRequest {
	return ApiApiV2AutoTestsIdWorkItemsChangedIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []string
func (a *AutoTestsApiService) ApiV2AutoTestsIdWorkItemsChangedIdGetExecute(r ApiApiV2AutoTestsIdWorkItemsChangedIdGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.ApiV2AutoTestsIdWorkItemsChangedIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}/workItems/changed/id"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV2AutoTestsIdWorkItemsChangedWorkItemIdApprovePostRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
	workItemId string
}

func (r ApiApiV2AutoTestsIdWorkItemsChangedWorkItemIdApprovePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV2AutoTestsIdWorkItemsChangedWorkItemIdApprovePostExecute(r)
}

/*
ApiV2AutoTestsIdWorkItemsChangedWorkItemIdApprovePost Approve changes to work items linked to autotest

User permissions for project:
- Read only
- Execute
- Write
- Full control

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param workItemId
 @return ApiApiV2AutoTestsIdWorkItemsChangedWorkItemIdApprovePostRequest
*/
func (a *AutoTestsApiService) ApiV2AutoTestsIdWorkItemsChangedWorkItemIdApprovePost(ctx context.Context, id string, workItemId string) ApiApiV2AutoTestsIdWorkItemsChangedWorkItemIdApprovePostRequest {
	return ApiApiV2AutoTestsIdWorkItemsChangedWorkItemIdApprovePostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		workItemId: workItemId,
	}
}

// Execute executes the request
func (a *AutoTestsApiService) ApiV2AutoTestsIdWorkItemsChangedWorkItemIdApprovePostExecute(r ApiApiV2AutoTestsIdWorkItemsChangedWorkItemIdApprovePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.ApiV2AutoTestsIdWorkItemsChangedWorkItemIdApprovePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}/workItems/changed/{workItemId}/approve"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workItemId"+"}", url.PathEscape(parameterValueToString(r.workItemId, "workItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV2AutoTestsSearchPostRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	skip *int32
	take *int32
	orderBy *string
	searchField *string
	searchValue *string
	autotestsSelectModel *AutotestsSelectModel
}

// Amount of items to be skipped (offset)
func (r ApiApiV2AutoTestsSearchPostRequest) Skip(skip int32) ApiApiV2AutoTestsSearchPostRequest {
	r.skip = &skip
	return r
}

// Amount of items to be taken (limit)
func (r ApiApiV2AutoTestsSearchPostRequest) Take(take int32) ApiApiV2AutoTestsSearchPostRequest {
	r.take = &take
	return r
}

// SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
func (r ApiApiV2AutoTestsSearchPostRequest) OrderBy(orderBy string) ApiApiV2AutoTestsSearchPostRequest {
	r.orderBy = &orderBy
	return r
}

// Property name for searching
func (r ApiApiV2AutoTestsSearchPostRequest) SearchField(searchField string) ApiApiV2AutoTestsSearchPostRequest {
	r.searchField = &searchField
	return r
}

// Value for searching
func (r ApiApiV2AutoTestsSearchPostRequest) SearchValue(searchValue string) ApiApiV2AutoTestsSearchPostRequest {
	r.searchValue = &searchValue
	return r
}

func (r ApiApiV2AutoTestsSearchPostRequest) AutotestsSelectModel(autotestsSelectModel AutotestsSelectModel) ApiApiV2AutoTestsSearchPostRequest {
	r.autotestsSelectModel = &autotestsSelectModel
	return r
}

func (r ApiApiV2AutoTestsSearchPostRequest) Execute() ([]AutoTestModel, *http.Response, error) {
	return r.ApiService.ApiV2AutoTestsSearchPostExecute(r)
}

/*
ApiV2AutoTestsSearchPost Search for autotests

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV2AutoTestsSearchPostRequest
*/
func (a *AutoTestsApiService) ApiV2AutoTestsSearchPost(ctx context.Context) ApiApiV2AutoTestsSearchPostRequest {
	return ApiApiV2AutoTestsSearchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AutoTestModel
func (a *AutoTestsApiService) ApiV2AutoTestsSearchPostExecute(r ApiApiV2AutoTestsSearchPostRequest) ([]AutoTestModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AutoTestModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.ApiV2AutoTestsSearchPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Skip", r.skip, "")
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Take", r.take, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OrderBy", r.orderBy, "")
	}
	if r.searchField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchField", r.searchField, "")
	}
	if r.searchValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchValue", r.searchValue, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.autotestsSelectModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAutoTestRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	autoTestPostModel *AutoTestPostModel
}

func (r ApiCreateAutoTestRequest) AutoTestPostModel(autoTestPostModel AutoTestPostModel) ApiCreateAutoTestRequest {
	r.autoTestPostModel = &autoTestPostModel
	return r
}

func (r ApiCreateAutoTestRequest) Execute() (*AutoTestModel, *http.Response, error) {
	return r.ApiService.CreateAutoTestExecute(r)
}

/*
CreateAutoTest Create autotest

<br>This method creates a new autotest.
<br>To add an autotest to the test plan, link it to a work item using the `POST /api/v2/autoTests/{autoTestId}/workItems` method.
<br>Use the `POST /api/v2/testRuns/byAutoTests` method to run autotest outside the test plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAutoTestRequest
*/
func (a *AutoTestsApiService) CreateAutoTest(ctx context.Context) ApiCreateAutoTestRequest {
	return ApiCreateAutoTestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AutoTestModel
func (a *AutoTestsApiService) CreateAutoTestExecute(r ApiCreateAutoTestRequest) (*AutoTestModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoTestModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.CreateAutoTest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.autoTestPostModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMultipleRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	autoTestPostModel *[]AutoTestPostModel
}

func (r ApiCreateMultipleRequest) AutoTestPostModel(autoTestPostModel []AutoTestPostModel) ApiCreateMultipleRequest {
	r.autoTestPostModel = &autoTestPostModel
	return r
}

func (r ApiCreateMultipleRequest) Execute() ([]AutoTestModel, *http.Response, error) {
	return r.ApiService.CreateMultipleExecute(r)
}

/*
CreateMultiple Create multiple autotests

<br>Use case
<br>User sets autotest parameters (listed in the example) and runs method execution
<br>System creates autotest
<br>[Optional] If steps enumeration is set, system creates step items and relates them to autotest
<br>[Optional] If setup enumeration is set, system creates setup items and relates them to autotest
<br>[Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest
<br>[Optional] If label enumeration is set, system creates labels and relates them to autotest
<br>[Optional] If link enumeration is set, system creates links and relates them to autotest
<br>System returns autotest model (example listed in response parameters)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMultipleRequest
*/
func (a *AutoTestsApiService) CreateMultiple(ctx context.Context) ApiCreateMultipleRequest {
	return ApiCreateMultipleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AutoTestModel
func (a *AutoTestsApiService) CreateMultipleExecute(r ApiCreateMultipleRequest) ([]AutoTestModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AutoTestModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.CreateMultiple")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.autoTestPostModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAutoTestRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
}

func (r ApiDeleteAutoTestRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAutoTestExecute(r)
}

/*
DeleteAutoTest Delete autotest

<br>Use case
<br>User sets autotest internal (guid format) or global (integer format) identifier and runs method execution
<br>System finds the autotest by the identifier
<br>System deletes autotest and returns no content response

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Autotest internal (UUID) or global (integer) identifier
 @return ApiDeleteAutoTestRequest
*/
func (a *AutoTestsApiService) DeleteAutoTest(ctx context.Context, id string) ApiDeleteAutoTestRequest {
	return ApiDeleteAutoTestRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AutoTestsApiService) DeleteAutoTestExecute(r ApiDeleteAutoTestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.DeleteAutoTest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAutoTestLinkFromWorkItemRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
	workItemId *string
}

// Work item internal (UUID) or global (integer) identifier
func (r ApiDeleteAutoTestLinkFromWorkItemRequest) WorkItemId(workItemId string) ApiDeleteAutoTestLinkFromWorkItemRequest {
	r.workItemId = &workItemId
	return r
}

func (r ApiDeleteAutoTestLinkFromWorkItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAutoTestLinkFromWorkItemExecute(r)
}

/*
DeleteAutoTestLinkFromWorkItem Unlink autotest from work item

<br>Use case
<br>User sets autotest internal (guid format) or global (integer format) identifier
<br>[Optional] User sets workitem internal (guid format) or global (integer format) identifier
<br>User runs method execution
<br>System finds the autotest by the autotest identifier
<br>
            [Optional] if workitem id is set by User, System finds the workitem by the workitem identifier and unlinks it
            from autotest.
            
<br>[Optional] Otherwise, if workitem id is not specified, System unlinks all workitems linked to autotest.
<br>System returns no content response

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Autotest internal (UUID) or global (integer) identifier
 @return ApiDeleteAutoTestLinkFromWorkItemRequest
*/
func (a *AutoTestsApiService) DeleteAutoTestLinkFromWorkItem(ctx context.Context, id string) ApiDeleteAutoTestLinkFromWorkItemRequest {
	return ApiDeleteAutoTestLinkFromWorkItemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AutoTestsApiService) DeleteAutoTestLinkFromWorkItemExecute(r ApiDeleteAutoTestLinkFromWorkItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.DeleteAutoTestLinkFromWorkItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}/workItems"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.workItemId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "workItemId", r.workItemId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllAutoTestsRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	projectId *string
	externalId *string
	globalId *int64
	namespace *string
	isNamespaceNull *bool
	includeEmptyNamespaces *bool
	className *string
	isClassnameNull *bool
	includeEmptyClassNames *bool
	isDeleted *bool
	deleted *bool
	labels *[]string
	stabilityMinimal *int32
	minStability *int32
	stabilityMaximal *int32
	maxStability *int32
	isFlaky *bool
	flaky *bool
	includeSteps *bool
	includeLabels *bool
	skip *int32
	take *int32
	orderBy *string
	searchField *string
	searchValue *string
}

// Project internal ID
func (r ApiGetAllAutoTestsRequest) ProjectId(projectId string) ApiGetAllAutoTestsRequest {
	r.projectId = &projectId
	return r
}

// Autotest external ID
func (r ApiGetAllAutoTestsRequest) ExternalId(externalId string) ApiGetAllAutoTestsRequest {
	r.externalId = &externalId
	return r
}

// Autotest global ID
func (r ApiGetAllAutoTestsRequest) GlobalId(globalId int64) ApiGetAllAutoTestsRequest {
	r.globalId = &globalId
	return r
}

// Namespace in which autotest is located
func (r ApiGetAllAutoTestsRequest) Namespace(namespace string) ApiGetAllAutoTestsRequest {
	r.namespace = &namespace
	return r
}

// OBSOLETE: Use &#x60;includeEmptyNamespaces&#x60; instead
func (r ApiGetAllAutoTestsRequest) IsNamespaceNull(isNamespaceNull bool) ApiGetAllAutoTestsRequest {
	r.isNamespaceNull = &isNamespaceNull
	return r
}

// If result must contain autotests without namespace
func (r ApiGetAllAutoTestsRequest) IncludeEmptyNamespaces(includeEmptyNamespaces bool) ApiGetAllAutoTestsRequest {
	r.includeEmptyNamespaces = &includeEmptyNamespaces
	return r
}

// Name of class in which autotest is located
func (r ApiGetAllAutoTestsRequest) ClassName(className string) ApiGetAllAutoTestsRequest {
	r.className = &className
	return r
}

// OBSOLETE: Use &#x60;includeEmptyClassNames&#x60; instead
func (r ApiGetAllAutoTestsRequest) IsClassnameNull(isClassnameNull bool) ApiGetAllAutoTestsRequest {
	r.isClassnameNull = &isClassnameNull
	return r
}

// If result must contain autotests without class
func (r ApiGetAllAutoTestsRequest) IncludeEmptyClassNames(includeEmptyClassNames bool) ApiGetAllAutoTestsRequest {
	r.includeEmptyClassNames = &includeEmptyClassNames
	return r
}

// OBSOLETE: Use &#x60;deleted&#x60; instead
func (r ApiGetAllAutoTestsRequest) IsDeleted(isDeleted bool) ApiGetAllAutoTestsRequest {
	r.isDeleted = &isDeleted
	return r
}

// Is autotest deleted
func (r ApiGetAllAutoTestsRequest) Deleted(deleted bool) ApiGetAllAutoTestsRequest {
	r.deleted = &deleted
	return r
}

// Include only autotests with provided labels
func (r ApiGetAllAutoTestsRequest) Labels(labels []string) ApiGetAllAutoTestsRequest {
	r.labels = &labels
	return r
}

// OBSOLETE: Use &#x60;minStability&#x60; instead
func (r ApiGetAllAutoTestsRequest) StabilityMinimal(stabilityMinimal int32) ApiGetAllAutoTestsRequest {
	r.stabilityMinimal = &stabilityMinimal
	return r
}

// Minimum stability value of autotest
func (r ApiGetAllAutoTestsRequest) MinStability(minStability int32) ApiGetAllAutoTestsRequest {
	r.minStability = &minStability
	return r
}

// OBSOLETE: Use &#x60;maxStability&#x60; instead
func (r ApiGetAllAutoTestsRequest) StabilityMaximal(stabilityMaximal int32) ApiGetAllAutoTestsRequest {
	r.stabilityMaximal = &stabilityMaximal
	return r
}

// Maximum stability value of autotest
func (r ApiGetAllAutoTestsRequest) MaxStability(maxStability int32) ApiGetAllAutoTestsRequest {
	r.maxStability = &maxStability
	return r
}

// OBSOLETE: Use &#x60;flaky&#x60; instead
func (r ApiGetAllAutoTestsRequest) IsFlaky(isFlaky bool) ApiGetAllAutoTestsRequest {
	r.isFlaky = &isFlaky
	return r
}

// Is autotest marked as \&quot;Flaky\&quot;
func (r ApiGetAllAutoTestsRequest) Flaky(flaky bool) ApiGetAllAutoTestsRequest {
	r.flaky = &flaky
	return r
}

// If result must also include autotest steps
func (r ApiGetAllAutoTestsRequest) IncludeSteps(includeSteps bool) ApiGetAllAutoTestsRequest {
	r.includeSteps = &includeSteps
	return r
}

// If result must also include autotest labels
func (r ApiGetAllAutoTestsRequest) IncludeLabels(includeLabels bool) ApiGetAllAutoTestsRequest {
	r.includeLabels = &includeLabels
	return r
}

// Amount of items to be skipped (offset)
func (r ApiGetAllAutoTestsRequest) Skip(skip int32) ApiGetAllAutoTestsRequest {
	r.skip = &skip
	return r
}

// Amount of items to be taken (limit)
func (r ApiGetAllAutoTestsRequest) Take(take int32) ApiGetAllAutoTestsRequest {
	r.take = &take
	return r
}

// SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
func (r ApiGetAllAutoTestsRequest) OrderBy(orderBy string) ApiGetAllAutoTestsRequest {
	r.orderBy = &orderBy
	return r
}

// Property name for searching
func (r ApiGetAllAutoTestsRequest) SearchField(searchField string) ApiGetAllAutoTestsRequest {
	r.searchField = &searchField
	return r
}

// Value for searching
func (r ApiGetAllAutoTestsRequest) SearchValue(searchValue string) ApiGetAllAutoTestsRequest {
	r.searchValue = &searchValue
	return r
}

func (r ApiGetAllAutoTestsRequest) Execute() ([]AutoTestModel, *http.Response, error) {
	return r.ApiService.GetAllAutoTestsExecute(r)
}

/*
GetAllAutoTests Method for GetAllAutoTests

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllAutoTestsRequest

Deprecated
*/
func (a *AutoTestsApiService) GetAllAutoTests(ctx context.Context) ApiGetAllAutoTestsRequest {
	return ApiGetAllAutoTestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AutoTestModel
// Deprecated
func (a *AutoTestsApiService) GetAllAutoTestsExecute(r ApiGetAllAutoTestsRequest) ([]AutoTestModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AutoTestModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.GetAllAutoTests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.projectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", r.projectId, "")
	}
	if r.externalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalId", r.externalId, "")
	}
	if r.globalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalId", r.globalId, "")
	}
	if r.namespace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "")
	}
	if r.isNamespaceNull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNamespaceNull", r.isNamespaceNull, "")
	}
	if r.includeEmptyNamespaces != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeEmptyNamespaces", r.includeEmptyNamespaces, "")
	}
	if r.className != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "className", r.className, "")
	}
	if r.isClassnameNull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isClassnameNull", r.isClassnameNull, "")
	}
	if r.includeEmptyClassNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeEmptyClassNames", r.includeEmptyClassNames, "")
	}
	if r.isDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isDeleted", r.isDeleted, "")
	}
	if r.deleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted", r.deleted, "")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels", t, "multi")
		}
	}
	if r.stabilityMinimal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stabilityMinimal", r.stabilityMinimal, "")
	}
	if r.minStability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minStability", r.minStability, "")
	}
	if r.stabilityMaximal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stabilityMaximal", r.stabilityMaximal, "")
	}
	if r.maxStability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxStability", r.maxStability, "")
	}
	if r.isFlaky != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isFlaky", r.isFlaky, "")
	}
	if r.flaky != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flaky", r.flaky, "")
	}
	if r.includeSteps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSteps", r.includeSteps, "")
	}
	if r.includeLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLabels", r.includeLabels, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Skip", r.skip, "")
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Take", r.take, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OrderBy", r.orderBy, "")
	}
	if r.searchField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchField", r.searchField, "")
	}
	if r.searchValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchValue", r.searchValue, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutoTestAverageDurationRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
}

func (r ApiGetAutoTestAverageDurationRequest) Execute() (*AutoTestAverageDurationModel, *http.Response, error) {
	return r.ApiService.GetAutoTestAverageDurationExecute(r)
}

/*
GetAutoTestAverageDuration Get average autotest duration

<br>Use case
<br>User sets autotest internal (guid format) or global (integer format) identifier
<br>User runs method execution
<br>System calculates pass average duration and fail average duration of autotest from all related test results
<br>System returns pass average duration and fail average duration for autotest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Autotest internal (UUID) or global (integer) identifier
 @return ApiGetAutoTestAverageDurationRequest
*/
func (a *AutoTestsApiService) GetAutoTestAverageDuration(ctx context.Context, id string) ApiGetAutoTestAverageDurationRequest {
	return ApiGetAutoTestAverageDurationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AutoTestAverageDurationModel
func (a *AutoTestsApiService) GetAutoTestAverageDurationExecute(r ApiGetAutoTestAverageDurationRequest) (*AutoTestAverageDurationModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoTestAverageDurationModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.GetAutoTestAverageDuration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}/averageDuration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutoTestByIdRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
}

func (r ApiGetAutoTestByIdRequest) Execute() (*AutoTestModel, *http.Response, error) {
	return r.ApiService.GetAutoTestByIdExecute(r)
}

/*
GetAutoTestById Get autotest by internal or global ID

<br>Use case
<br>User sets autotest internal or global identifier and runs method execution
<br>System returns autotest, which internal or global identifier equals the identifier value set in the previous action

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Autotest internal (UUID) or global (integer) identifier
 @return ApiGetAutoTestByIdRequest
*/
func (a *AutoTestsApiService) GetAutoTestById(ctx context.Context, id string) ApiGetAutoTestByIdRequest {
	return ApiGetAutoTestByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AutoTestModel
func (a *AutoTestsApiService) GetAutoTestByIdExecute(r ApiGetAutoTestByIdRequest) (*AutoTestModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutoTestModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.GetAutoTestById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutoTestChronologyRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
}

func (r ApiGetAutoTestChronologyRequest) Execute() ([]TestResultChronologyModel, *http.Response, error) {
	return r.ApiService.GetAutoTestChronologyExecute(r)
}

/*
GetAutoTestChronology Get autotest chronology

<br>Use case
<br>User sets autotest internal (guid format) or global (integer format) identifier
<br>User runs method execution
<br>System search all test results related to autotest (with default limit equal 100)
<br>System orders the test results by CompletedOn property descending and then orders by CreatedDate property descending
<br>System returns test result chronology for autotest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Autotest internal (UUID) or global (integer) identifier
 @return ApiGetAutoTestChronologyRequest
*/
func (a *AutoTestsApiService) GetAutoTestChronology(ctx context.Context, id string) ApiGetAutoTestChronologyRequest {
	return ApiGetAutoTestChronologyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []TestResultChronologyModel
func (a *AutoTestsApiService) GetAutoTestChronologyExecute(r ApiGetAutoTestChronologyRequest) ([]TestResultChronologyModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TestResultChronologyModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.GetAutoTestChronology")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}/chronology"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTestRunsRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
}

func (r ApiGetTestRunsRequest) Execute() ([]TestRunShortModel, *http.Response, error) {
	return r.ApiService.GetTestRunsExecute(r)
}

/*
GetTestRuns Get completed tests runs for autotests

<br>Use case
<br>User sets autotest internal (guid format) or global (integer format) identifier
<br>User runs method execution
<br>System search for all test runs related to the autotest
<br>System returns the enumeration of test runs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Autotest internal (UUID) or global (integer) identifier
 @return ApiGetTestRunsRequest
*/
func (a *AutoTestsApiService) GetTestRuns(ctx context.Context, id string) ApiGetTestRunsRequest {
	return ApiGetTestRunsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []TestRunShortModel
func (a *AutoTestsApiService) GetTestRunsExecute(r ApiGetTestRunsRequest) ([]TestRunShortModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TestRunShortModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.GetTestRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}/testRuns"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorkItemResultsRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
	from *time.Time
	to *time.Time
	configurationIds *[]string
	testPlanIds *[]string
	userIds *[]string
	outcomes *[]string
	isAutomated *bool
	automated *bool
	testRunIds *[]string
	skip *int32
	take *int32
	orderBy *string
	searchField *string
	searchValue *string
}

// Take results from this date
func (r ApiGetWorkItemResultsRequest) From(from time.Time) ApiGetWorkItemResultsRequest {
	r.from = &from
	return r
}

// Take results until this date
func (r ApiGetWorkItemResultsRequest) To(to time.Time) ApiGetWorkItemResultsRequest {
	r.to = &to
	return r
}

// Identifiers of test result configurations
func (r ApiGetWorkItemResultsRequest) ConfigurationIds(configurationIds []string) ApiGetWorkItemResultsRequest {
	r.configurationIds = &configurationIds
	return r
}

// Identifiers of test plans which contain test results
func (r ApiGetWorkItemResultsRequest) TestPlanIds(testPlanIds []string) ApiGetWorkItemResultsRequest {
	r.testPlanIds = &testPlanIds
	return r
}

// Identifiers of users who set test results
func (r ApiGetWorkItemResultsRequest) UserIds(userIds []string) ApiGetWorkItemResultsRequest {
	r.userIds = &userIds
	return r
}

// List of outcomes of test results
func (r ApiGetWorkItemResultsRequest) Outcomes(outcomes []string) ApiGetWorkItemResultsRequest {
	r.outcomes = &outcomes
	return r
}

// OBSOLETE: Use &#x60;Automated&#x60; instead
func (r ApiGetWorkItemResultsRequest) IsAutomated(isAutomated bool) ApiGetWorkItemResultsRequest {
	r.isAutomated = &isAutomated
	return r
}

// If result must consist of only manual/automated test results
func (r ApiGetWorkItemResultsRequest) Automated(automated bool) ApiGetWorkItemResultsRequest {
	r.automated = &automated
	return r
}

// Identifiers of test runs which contain test results
func (r ApiGetWorkItemResultsRequest) TestRunIds(testRunIds []string) ApiGetWorkItemResultsRequest {
	r.testRunIds = &testRunIds
	return r
}

// Amount of items to be skipped (offset)
func (r ApiGetWorkItemResultsRequest) Skip(skip int32) ApiGetWorkItemResultsRequest {
	r.skip = &skip
	return r
}

// Amount of items to be taken (limit)
func (r ApiGetWorkItemResultsRequest) Take(take int32) ApiGetWorkItemResultsRequest {
	r.take = &take
	return r
}

// SQL-like  ORDER BY statement (column1 ASC|DESC , column2 ASC|DESC)
func (r ApiGetWorkItemResultsRequest) OrderBy(orderBy string) ApiGetWorkItemResultsRequest {
	r.orderBy = &orderBy
	return r
}

// Property name for searching
func (r ApiGetWorkItemResultsRequest) SearchField(searchField string) ApiGetWorkItemResultsRequest {
	r.searchField = &searchField
	return r
}

// Value for searching
func (r ApiGetWorkItemResultsRequest) SearchValue(searchValue string) ApiGetWorkItemResultsRequest {
	r.searchValue = &searchValue
	return r
}

func (r ApiGetWorkItemResultsRequest) Execute() ([]TestResultHistoryReportModel, *http.Response, error) {
	return r.ApiService.GetWorkItemResultsExecute(r)
}

/*
GetWorkItemResults Method for GetWorkItemResults

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetWorkItemResultsRequest

Deprecated
*/
func (a *AutoTestsApiService) GetWorkItemResults(ctx context.Context, id string) ApiGetWorkItemResultsRequest {
	return ApiGetWorkItemResultsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []TestResultHistoryReportModel
// Deprecated
func (a *AutoTestsApiService) GetWorkItemResultsExecute(r ApiGetWorkItemResultsRequest) ([]TestResultHistoryReportModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TestResultHistoryReportModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.GetWorkItemResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}/testResultHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	if r.configurationIds != nil {
		t := *r.configurationIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "configurationIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "configurationIds", t, "multi")
		}
	}
	if r.testPlanIds != nil {
		t := *r.testPlanIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "testPlanIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "testPlanIds", t, "multi")
		}
	}
	if r.userIds != nil {
		t := *r.userIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "userIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "userIds", t, "multi")
		}
	}
	if r.outcomes != nil {
		t := *r.outcomes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outcomes", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outcomes", t, "multi")
		}
	}
	if r.isAutomated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isAutomated", r.isAutomated, "")
	}
	if r.automated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "automated", r.automated, "")
	}
	if r.testRunIds != nil {
		t := *r.testRunIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "testRunIds", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "testRunIds", t, "multi")
		}
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Skip", r.skip, "")
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Take", r.take, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "OrderBy", r.orderBy, "")
	}
	if r.searchField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchField", r.searchField, "")
	}
	if r.searchValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "SearchValue", r.searchValue, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorkItemsLinkedToAutoTestRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
	isDeleted *bool
	isWorkItemDeleted *bool
}

// Specifies that a test is deleted or still relevant.
func (r ApiGetWorkItemsLinkedToAutoTestRequest) IsDeleted(isDeleted bool) ApiGetWorkItemsLinkedToAutoTestRequest {
	r.isDeleted = &isDeleted
	return r
}

// OBSOLETE: Use &#x60;isDeleted&#x60; instead
func (r ApiGetWorkItemsLinkedToAutoTestRequest) IsWorkItemDeleted(isWorkItemDeleted bool) ApiGetWorkItemsLinkedToAutoTestRequest {
	r.isWorkItemDeleted = &isWorkItemDeleted
	return r
}

func (r ApiGetWorkItemsLinkedToAutoTestRequest) Execute() ([]WorkItemIdentifierModel, *http.Response, error) {
	return r.ApiService.GetWorkItemsLinkedToAutoTestExecute(r)
}

/*
GetWorkItemsLinkedToAutoTest Get work items linked to autotest

<br>
            This method links an autotest to a test case or a checklist.
            A manual test case with a linked automated work item is marked in the test management system as an autotest.
            You can run it from graphical user interface (GUI). To do that:
            
<br>
            1. Open the project in GUI.<br />
            2. Go to <b>Test plans</b> section and switch to the <b>Execution</b> tab.<br />
            3. Select the autotest(s) you want to run using checkboxes.<br />
            4. In the toolbar above the test list, click <b>Run autotests</b>.
            

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the autotest entity ID.<br />  You can copy it from the address bar in your web browser or use autotest GUID.
 @return ApiGetWorkItemsLinkedToAutoTestRequest
*/
func (a *AutoTestsApiService) GetWorkItemsLinkedToAutoTest(ctx context.Context, id string) ApiGetWorkItemsLinkedToAutoTestRequest {
	return ApiGetWorkItemsLinkedToAutoTestRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []WorkItemIdentifierModel
func (a *AutoTestsApiService) GetWorkItemsLinkedToAutoTestExecute(r ApiGetWorkItemsLinkedToAutoTestRequest) ([]WorkItemIdentifierModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []WorkItemIdentifierModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.GetWorkItemsLinkedToAutoTest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}/workItems"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isDeleted", r.isDeleted, "")
	}
	if r.isWorkItemDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isWorkItemDeleted", r.isWorkItemDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkAutoTestToWorkItemRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	id string
	workItemIdModel *WorkItemIdModel
}

func (r ApiLinkAutoTestToWorkItemRequest) WorkItemIdModel(workItemIdModel WorkItemIdModel) ApiLinkAutoTestToWorkItemRequest {
	r.workItemIdModel = &workItemIdModel
	return r
}

func (r ApiLinkAutoTestToWorkItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.LinkAutoTestToWorkItemExecute(r)
}

/*
LinkAutoTestToWorkItem Link autotest with work items

<br>Use case
<br>User sets autotest internal (guid format) or global (integer format) identifier
<br>User sets work item internal (guid format) or global (integer format) identifier
<br>User runs method execution
<br>System finds the autotest by the autotest identifier
<br>System finds the work item by the work item identifier
<br>System relates the work item with the autotest and returns no content response

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Autotest internal (UUID) or global (integer) identifier
 @return ApiLinkAutoTestToWorkItemRequest
*/
func (a *AutoTestsApiService) LinkAutoTestToWorkItem(ctx context.Context, id string) ApiLinkAutoTestToWorkItemRequest {
	return ApiLinkAutoTestToWorkItemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AutoTestsApiService) LinkAutoTestToWorkItemExecute(r ApiLinkAutoTestToWorkItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.LinkAutoTestToWorkItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/{id}/workItems"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workItemIdModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAutoTestRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	autoTestPutModel *AutoTestPutModel
}

func (r ApiUpdateAutoTestRequest) AutoTestPutModel(autoTestPutModel AutoTestPutModel) ApiUpdateAutoTestRequest {
	r.autoTestPutModel = &autoTestPutModel
	return r
}

func (r ApiUpdateAutoTestRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAutoTestExecute(r)
}

/*
UpdateAutoTest Update autotest

<br>Use case
<br>User sets autotest updated parameters values (listed in the example) and runs method execution
<br>System finds the autotest by the identifier
<br>System updates autotest parameters 
<br>
            [Optional] If steps enumeration is set, system creates step items, relates them to autotest
            and deletes relations with current steps( if exist)
            
<br>
            [Optional] If Setup enumeration is set, system creates setup items and relates them to autotest
            and deletes relations with current Setup items (if exist)
            
<br>
            [Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest
            and deletes relations with current teardown items (if exist)
            
<br>
            [Optional] If label enumeration is set, system creates labels and relates them to autotest
            and deletes relations with current Labels (if exist)
            
<br>
            [Optional] If link enumeration is set, system creates links and relates them to autotest
            and deletes relations with current Links (if exist)
            
<br>System updates autotest and returns no content response

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAutoTestRequest
*/
func (a *AutoTestsApiService) UpdateAutoTest(ctx context.Context) ApiUpdateAutoTestRequest {
	return ApiUpdateAutoTestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AutoTestsApiService) UpdateAutoTestExecute(r ApiUpdateAutoTestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.UpdateAutoTest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.autoTestPutModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateMultipleRequest struct {
	ctx context.Context
	ApiService *AutoTestsApiService
	autoTestPutModel *[]AutoTestPutModel
}

func (r ApiUpdateMultipleRequest) AutoTestPutModel(autoTestPutModel []AutoTestPutModel) ApiUpdateMultipleRequest {
	r.autoTestPutModel = &autoTestPutModel
	return r
}

func (r ApiUpdateMultipleRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateMultipleExecute(r)
}

/*
UpdateMultiple Update multiple autotests

<br>Use case
<br>User sets autotest updated parameters values (listed in the example) and runs method execution
<br>System finds the autotest by the identifier
<br>System updates autotest parameters 
<br>
            [Optional] If steps enumeration is set, system creates step items, relates them to autotest
            and deletes relations with current steps( if exist)
            
<br>
            [Optional] If Setup enumeration is set, system creates setup items and relates them to autotest
            and deletes relations with current Setup items (if exist)
            
<br>
            [Optional] If teardown enumeration is set, system creates teardown items and relates them to autotest
            and deletes relations with current teardown items (if exist)
            
<br>
            [Optional] If label enumeration is set, system creates labels and relates them to autotest
            and deletes relations with current Labels (if exist)
            
<br>
            [Optional] If link enumeration is set, system creates links and relates them to autotest
            and deletes relations with current Links (if exist)
            
<br>System updates autotest and returns no content response

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateMultipleRequest
*/
func (a *AutoTestsApiService) UpdateMultiple(ctx context.Context) ApiUpdateMultipleRequest {
	return ApiUpdateMultipleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AutoTestsApiService) UpdateMultipleExecute(r ApiUpdateMultipleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutoTestsApiService.UpdateMultiple")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/autoTests/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.autoTestPutModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer or PrivateToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
